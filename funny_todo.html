<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>青鳥地獄大亂鬥</title>
  <style>
    body { margin:0; background:#000; overflow:hidden; }
    canvas { display:block; margin:0 auto; background:#111; }
    #score { position:absolute; top:10px; left:10px; color:#0f0; font-size:20px; }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<div id="score">Score: 0</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// 玩家
let player = { x:400, y:300, r:15, speed:4, dx:0, dy:0, name:"牢柯" };
let keys = {};
let score = 0;
let gameOver = false;

// 敵人陣列
let enemies = [];
let bullets = [];
let lastSpawn = 0;
let lastBoss = 0;

// 青鳥類型定義
const enemyTypes = [
  {name:"青鳥士兵", behavior:"melee"},
  {name:"青鳥守衛", behavior:"dash"},
  {name:"青鳥巨人", behavior:"tank"},
  {name:"青鳥刺客", behavior:"teleport"},
  {name:"青鳥狂戰士", behavior:"berserk"},
  {name:"青鳥弓手", behavior:"shoot"},
  {name:"青鳥槍兵", behavior:"spread"},
  {name:"青鳥砲手", behavior:"bigshot"},
  {name:"青鳥狙擊手", behavior:"sniper"},
  {name:"青鳥導彈兵", behavior:"homing"},
  {name:"青鳥巫師", behavior:"circle"},
  {name:"青鳥祭司", behavior:"cross"},
  {name:"青鳥幻術師", behavior:"randomshot"},
  {name:"青鳥風暴兵", behavior:"spiral"},
  {name:"青鳥冰法", behavior:"slow"},
  {name:"青鳥風法", behavior:"curve"},
  {name:"青鳥閃電師", behavior:"laser"},
  {name:"青鳥醫者", behavior:"heal"},
  {name:"青鳥增幅者", behavior:"buff"},
  {name:"青鳥召喚師", behavior:"summon"},
  {name:"青鳥自爆兵", behavior:"suicide"},
  {name:"青鳥分裂者", behavior:"split"},
  {name:"青鳥詛咒者", behavior:"curse"}
];

// 控制
document.addEventListener("keydown", e => keys[e.key]=true);
document.addEventListener("keyup", e => keys[e.key]=false);

function movePlayer(){
  player.dx = (keys["ArrowRight"]||keys["d"]?1:0) - (keys["ArrowLeft"]||keys["a"]?1:0);
  player.dy = (keys["ArrowDown"]||keys["s"]?1:0) - (keys["ArrowUp"]||keys["w"]?1:0);
  player.x += player.dx * player.speed;
  player.y += player.dy * player.speed;
  if(player.x<player.r) player.x=player.r;
  if(player.y<player.r) player.y=player.r;
  if(player.x>canvas.width-player.r) player.x=canvas.width-player.r;
  if(player.y>canvas.height-player.r) player.y=canvas.height-player.r;
}

// 繪製圓球+文字
function drawBall(obj, color){
  ctx.beginPath();
  ctx.arc(obj.x,obj.y,obj.r,0,Math.PI*2);
  ctx.fillStyle=color;
  ctx.fill();
  ctx.closePath();
  ctx.fillStyle="#fff";
  ctx.font="12px Arial";
  ctx.textAlign="center";
  ctx.fillText(obj.name,obj.x,obj.y-obj.r-5);
}

// 碰撞檢測
function collide(a,b){
  let dx=a.x-b.x, dy=a.y-b.y;
  return Math.sqrt(dx*dx+dy*dy) < a.r+b.r;
}

// 生成敵人
function spawnEnemy(typeIdx, isBoss=false){
  let side=Math.floor(Math.random()*4);
  let x=0,y=0;
  if(side===0){x=Math.random()*canvas.width;y=0;}
  else if(side===1){x=canvas.width;y=Math.random()*canvas.height;}
  else if(side===2){x=Math.random()*canvas.width;y=canvas.height;}
  else {x=0;y=Math.random()*canvas.height;}

  let baseType = enemyTypes[typeIdx];
  let enemy = {
    x:x,y:y,r:isBoss?40:15,
    name:isBoss?"青鳥王":"青鳥"+baseType.name.slice(2),
    type:isBoss?"boss":baseType.behavior,
    hp:isBoss?50:3,
    cooldown:0,
    angle:0
  };
  enemies.push(enemy);
}

// 更新敵人
function updateEnemies(){
  for(let e of enemies){
    let dx=player.x-e.x, dy=player.y-e.y, dist=Math.hypot(dx,dy);
    if(e.type==="melee"){e.x+=dx/dist*1.2; e.y+=dy/dist*1.2;}
    if(e.type==="dash"){if(e.cooldown<=0){e.vx=dx/dist*6; e.vy=dy/dist*6; e.cooldown=60;} e.x+=e.vx||0; e.y+=e.vy||0; e.cooldown--;}
    if(e.type==="tank"){e.x+=dx/dist*0.5; e.y+=dy/dist*0.5;}
    if(e.type==="teleport"){if(e.cooldown<=0){e.x=player.x+Math.random()*100-50; e.y=player.y+Math.random()*100-50; e.cooldown=180;} e.cooldown--;}
    if(e.type==="berserk"){let spd=2+(1000-score/50)*0.01; e.x+=dx/dist*spd; e.y+=dy/dist*spd;}
    if(e.type==="shoot"){if(e.cooldown<=0){bullets.push({x:e.x,y:e.y,dx:dx/dist*3,dy:dy/dist*3,r:5,color:"lime"});e.cooldown=90;} e.cooldown--;}
    if(e.type==="spread"){if(e.cooldown<=0){for(let ang=-0.3;ang<=0.3;ang+=0.3){let ndx=Math.cos(Math.atan2(dy,dx)+ang)*3;let ndy=Math.sin(Math.atan2(dy,dx)+ang)*3;bullets.push({x:e.x,y:e.y,dx:ndx,dy:ndy,r:5,color:"lime"});} e.cooldown=120;} e.cooldown--;}
    if(e.type==="bigshot"){if(e.cooldown<=0){bullets.push({x:e.x,y:e.y,dx:dx/dist*1.5,dy:dy/dist*1.5,r:12,color:"green"});e.cooldown=150;} e.cooldown--;}
    if(e.type==="sniper"){if(e.cooldown<=0){bullets.push({x:e.x,y:e.y,dx:dx/dist*7,dy:dy/dist*7,r:3,color:"white"});e.cooldown=200;} e.cooldown--;}
    if(e.type==="homing"){if(e.cooldown<=0){bullets.push({x:e.x,y:e.y,dx:dx/dist*2,dy:dy/dist*2,r:6,color:"yellow",homing:true});e.cooldown=180;} e.cooldown--;}
    if(e.type==="circle"){if(e.cooldown<=0){for(let ang=0;ang<Math.PI*2;ang+=Math.PI/6){bullets.push({x:e.x,y:e.y,dx:Math.cos(ang)*2,dy:Math.sin(ang)*2,r:4,color:"lime"});} e.cooldown=180;} e.cooldown--;}
    if(e.type==="cross"){if(e.cooldown<=0){let dirs=[[2,0],[-2,0],[0,2],[0,-2]];for(let d of dirs){bullets.push({x:e.x,y:e.y,dx:d[0],dy:d[1],r:4,color:"lime"});} e.cooldown=150;} e.cooldown--;}
    if(e.type==="randomshot"){if(e.cooldown<=0){for(let i=0;i<5;i++){let ang=Math.random()*Math.PI*2;bullets.push({x:e.x,y:e.y,dx:Math.cos(ang)*2,dy:Math.sin(ang)*2,r:3,color:"lime"});} e.cooldown=100;} e.cooldown--;}
    if(e.type==="spiral"){e.angle+=0.1;if(e.cooldown<=0){let ang=e.angle;bullets.push({x:e.x,y:e.y,dx:Math.cos(ang)*2,dy:Math.sin(ang)*2,r:3,color:"lime"});e.cooldown=5;} e.cooldown--;}
    if(e.type==="boss"){if(e.cooldown<=0){for(let ang=0;ang<Math.PI*2;ang+=Math.PI/12){bullets.push({x:e.x,y:e.y,dx:Math.cos(ang)*3,dy:Math.sin(ang)*3,r:6,color:"red"});} e.cooldown=100;} e.cooldown--;}
    // 其他特殊（heal,buff,summon...）這裡簡化略過
  }
}

// 更新子彈
function updateBullets(){
  for(let b of bullets){
    if(b.homing){
      let dx=player.x-b.x, dy=player.y-b.y, dist=Math.hypot(dx,dy);
      b.dx+=(dx/dist*0.1); b.dy+=(dy/dist*0.1);
    }
    b.x+=b.dx; b.y+=b.dy;
  }
  bullets=bullets.filter(b=>b.x>-20&&b.x<canvas.width+20&&b.y>-20&&b.y<canvas.height+20);
}

// 主遊戲迴圈
function loop(timestamp){
  if(gameOver){ctx.fillStyle="white";ctx.font="40px Arial";ctx.fillText("大吉大利，今晚吃雞鴨飯！",canvas.width/2,canvas.height/2);return;}
  ctx.clearRect(0,0,canvas.width,canvas.height);
  movePlayer();
  drawBall(player,"white");

  updateEnemies();
  updateBullets();

  for(let e of enemies){drawBall(e,"green");}
  for(let b of bullets){ctx.beginPath();ctx.arc(b.x,b.y,b.r,0,Math.PI*2);ctx.fillStyle=b.color;ctx.fill();ctx.closePath();}

  // 碰撞檢測
  for(let e of enemies){if(collide(player,e)){gameOver=true;}}
  for(let b of bullets){if(collide(player,b)){gameOver=true;}}

  // 生成敵人
  if(timestamp-lastSpawn>1000){spawnEnemy(Math.floor(Math.random()*enemyTypes.length)); lastSpawn=timestamp; score+=10;}
  // Boss生成規則
  if(score>100 && timestamp-lastBoss>20000){spawnEnemy(0,true); lastBoss=timestamp;}

  document.getElementById("score").innerText="Score: "+score;
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>

// 在主遊戲迴圈 loop() 裡，畫面更新時加上：
for (let e of enemies) {
  drawBall(e, "green");
  if (e.type === "boss") {
    ctx.fillStyle = "red";
    ctx.font = "20px Arial";
    ctx.textAlign = "center";
    ctx.fillText("你知道我綠色的恐怖了吧", e.x, e.y - e.r - 25);
  }
}

